一、为什么使用缓存？

      当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。

二、什么是redis缓存到mysql？

Redis其实就是说把表中经常访问的记录放在了Redis中，然后用户查询时先去查询Redis再去查询MySQL，确实实现了读写
分离，也就是Redis只做读操作。由于缓存在内存中，所以查询会很快。对于一个sql语句格式的数据请求，首先计算该语句的MD5并据此得到结果集标识符，然后利用该标识符在Redis中查找该结果集。注意，结果集中的每一行都有一个相应的键，这些键都存储在一个Redis集合结构中。如果Redis中不存在这样一个集合，说明要找的结果集不在Redis中，所以需要执行相应的sql语句，在Mysql中查询到相应的结果集，然后按照上面所说的办法把结果集中的每一行以字符串或哈希的形式存入Redis。
三、为什么使用redis做mysql的缓存，还有其他缓存策略吗？

Memcatched和Redis
1.性能上：
       性能上都很出色，具体到细节，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。
2.内存空间和数据量大小：
      MemCached可以修改最大内存，采用LRU算法。Redis增加了VM的特性，突破了物理内存的限制。
3.操作便利上：
      MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积。
4.可靠性上：
       MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。
5.应用场景：
       Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。

参考文章：https://www.cnblogs.com/work115/p/5584646.html

四、如何redis数据和mysql数据同步？

      redis其读取速度快，但是redis 怎么和数据库同步呢，怎么能把数据库的所有数据存到redis里面，能使用户更快速的查找。

方法1：mysql 同步到redis：解析mysql的binlog，然后做同步处理，可以使用的库有：open-replicator（https://github.com/whitesock/open-replicator）

方法2：同步redis数据到mysql：（https://github.com/leonchen83/redis-replicator）

后来发现，redis读取速度快，也没有必要把所有的数据都放到redis里面，redis里面只放使用频繁，用户操作量较大的数据，或者用户近期使用的数据。解决办法： 
1：读取数据的时候先从redis里面查，若没有，再去数据库查，同时写到redis里面，并且要设置失效时间。 
2：存数据的时候要具体情况具体分析，可以选择同时插到数据库和redis（要是存放到redis中，最好设置失效时间），也可以选择直接插到数据库里面，少考虑一些问题。









1.同步MySQL数据到Redis

(1) 在redis数据库设置缓存时间，当该条数据缓存时间过期之后自动释放，去数据库进行重新查询，但这样的话，我们放在缓存中的数据对数据的一致性要求不是很高才能放入缓存当中。

   例如：缓存量大但又不常变化的数据，比如商品信息的评论。

(2) 基于binlog使用mysql_udf_redis，将数据库中的数据同步到Redis。

​    无论MySQL还是Redis，自身都带有数据同步的机制，像比较常用的MySQL的Master/Slave模式，就是由Slave端分析Master的binlog来实现的，这样的数据其实还是一个异步过程，只不过当服务器都在同一内网时，异步的延迟几乎可以忽略。

   那么理论上我们也可以用同样方式，分析MySQL的binlog文件并将数据插入Redis。但是这需要对binlog文件以及MySQL有非常深入的理解，同时由于binlog存在Statement/Row/Mixedlevel多种形式，分析binlog实现同步的工作量是非常大的。

(3) 通过MySQL自动同步刷新Redis

   当我们在业务层有数据查询需求时，先到Redis缓存中查询，如果查不到，再到MySQL数据库中查询，同时将查到的数据更新到Redis里；当我们在业务层有修改插入数据需求时，直接向MySQL发起请求，同时更新Redis缓存。 就是MySQL的CRUD发生后自动地更新到Redis里，这需要通过MySQL UDF来实现。具体来说，我们把更新Redis的逻辑放到MySQL中去做，即定义一个触发器Trigger，监听CRUD这些操作，当操作发生后，调用对应的UDF函数，远程写回Redis，所以业务逻辑只需要负责更新MySQL就行了，剩下的交给MySQL UDF去完成。

   (4) 在我们的实际开发当中往往采用如下方式实现实现Mysql和Redis数据同步：当我们在MySQL数据库中进行增删改的时候，我们在增删改的service层将缓存中的数据清除，这个时候用户在此请求的时候我们缓存中没有数据了，直接去数据库中查询，查询回来之后将缓存中的数据放缓存当中，这个时候缓存中的数据就是最新的数据。

 

2.同步Redis到MySql

   redis读取速度快，也没有必要把所有的数据都放到redis里面，redis里面只放使用频繁，用户操作量较大的数据，或者用户近期使用的数据。

解决办法：

   (1) 读取数据的时候先从redis里面查，若没有，再去数据库查，同时写到redis里面，并且要设置失效时间。

   (2) 存数据的时候要具体情况具体分析，可以选择同时插到数据库和redis（要是存放到redis中，最好设置失效时间），也可以选择直接插到数据库里面，少考虑一些问题。

 

3.Redis应用场景

(1) 取最新N个数据的操作

   比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的5000条评论的ID放在Redis的List集合中，并将超出集合部分从数据库获取

使用LPUSH latest.comments<ID>命令，向list集合中插入数据,插入完成后再用LTRIM latest.comments 0 5000命令使其永远只保存最近5000个ID

然后我们在客户端获取某一页评论时可以用下面的逻辑（伪代码）

FUNCTION get_latest_comments(start,num_items):

  id_list = redis.lrange("latest.comments",start,start+num_items-1)

  IF id_list.length < num_items

​    id_list = SQL_DB("SELECT ... ORDER BY time LIMIT ...")

  END

  RETURN id_list

END

   如果你还有不同的筛选维度，比如某个分类的最新N条，那么你可以再建一个按此分类的List，只存ID的话，Redis是非常高效的。

(2) 排行榜应用，取TOP N操作

   这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。

(3) 需要精准设定过期时间的应用

   比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。

(4) 计数器应用

   Redis的命令都是原子性的，你可以轻松地利用INCR，DECR命令来构建计数器系统。

(5) Uniq操作，获取某段时间所有数据排重值

   这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。

(6) 实时系统，反垃圾系统

   通过上面说到的set功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。

(7) Pub/Sub构建实时消息系统

   Redis的Pub/Sub系统可以构建实时的消息系统，比如很多用Pub/Sub构建的实时聊天系统的例子。

(8) 构建队列系统

   使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。

(9) 缓存

 性能优于Memcached，数据结构更多样化
\---------------------