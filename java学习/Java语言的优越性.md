# java为什么不支持多继承
典型的支持多继承的语言就是C++。在OOP的世界里，单根继承意味着所有的类都会有一个最上面的终极类，java里面这个类就是Object。单根继承既可以说是一门语言的特性，也可以说是一门语言的一个选择。从纯粹技术的角度来说，java也可以做到多继承，只是如果那样的话那么java就不会再是我们今天所认识的java。除此之外，单根继承还有下面这些优点：

单根继承的优点1:兼容性

单根继承带来的一个效果就是所有的对象归根到底都是相同的基本类型。这带来的好处就是任何java出现的新类库中，兼容性的问题会大大降低，这一点很好理解。但是在C++之中，总是会有一些不兼容的接口，这虽然带来了一定的灵活性，但是对于不兼容的接口，往往就是要通过多继承来解决。

单根继承的优点2: 便利性

因为单根继承，所有的对象都会具备某些一样的功能，比如所有的对象都会有hashcode方法，有euqals方法。因此拿到一个对象时，无论这个对象从哪里来，我们都知道可以对他执行某些基本操作。参数传递也得到了简化。

单根继承的优点3: 垃圾回收

单根继承会使得垃圾回收变得简单很多。因为所有对象都保证具有其类型信息，因此不会因为无法确定类型信息而带来不便。垃圾回收正是java相对于C++的重要改进之一。



# Java类加载

1.类加载子系统的作用：根据给定的全限定名类名(如java.lang.Object)来装载class文件的内容到运行时数据区中的方法区
2.双亲委派机制：当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。
3.类加载过程：加载、链接（验证、准备、解析）、初始化
加载阶段，虚拟机需要完成以下3件事情：
1.通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
验证阶段大致会完成4个阶段的检验动作：
1.文件格式验证
2.元数据验证
3.字节码验证：

4. 符号引用验证
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器()方法的过程.



# 锁（lock、synchronized）



在Java中，每一个对象都拥有一个锁标记（锁），也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。

Lock和synchronized有以下几点不同：
　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
　　2）采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完后，系统会自动让线程释放对锁的占用；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
　　3）响应中断Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
　　4）Lock可以是否获取锁，synchronized不行。
5）Lock可以提高多个线程进行读操作的效率。
6） 公平锁Lock可以设置为公平锁，synchronized就是非公平锁

单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。
当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的（线程B调用threadB.interrupt()方法能够中断线程B的等待过程
）。
　　而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。



# 抽象类与接口的区别是什么

首先来看看接口的定义：接口，在JAVA编程语言中是一个抽象类型，主要是抽象方法的集合，接口中的变量定义必须为public static final类型。接口通常以interface来声明。

抽象类: 从面向对象的角度来讲，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样，并不是 所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就可以认为是抽象类。。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

从定义角度来看，接口和抽象类是两个几乎没有太多联系的设计。接口只是一个抽象方法的集合。而抽象类本质上是一个类，但是它不能被实例化，但是类具备的大多特性抽象类都有。抽象类和interface在Java语言中都是用来进行抽象的，他们除了都是一个用于抽象的东西之外几乎没有任何相同之处。事实上对于一个java里的类来说，无外乎由两种成分组成，即变量和方法（静态代码块可以写在类里面但从实际效果角度并没有影响一个类）。因此接口的功能仅仅包含其中一部分，即方法的集合以及一部分静态成员变量。这样来看，接口是一种非常高的抽象，里面定义的东西被认为是不会改变的。抽象类里面就可以定义普通的成员变量，抽象类的抽象程度相对接口来说会低一点。

但是对于java来说个人认为设计接口的最大原因是为了支持多继承，从这个角度来说，抽象类和接口最重要的区别应该是在使用的时候的区别：

类可以实现多个接口，但是只能继承一个类

其他的区别就非常多了，本质上是一些java语言规则方面的区别。例如：抽象类可以写方法实现，接口也可以写方法实现，不过需要加上default修饰，等等。

问题：什么时候用接口什么时候用抽象类？

抽象类的关键好处在于 能够实现面向对象设计的一个最核心的原则OCP(Open-ClosedPrinciple)。因此当我有一部分内容是不想让子类修改的，但是子类又都通用，同时各个自乐又有自己的特点，那么就适合使用抽象类。

在面向对象领域，抽象类主要用来进行类型隐藏。 我们可以构造出一个固定的一组行为的抽象描 述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个 抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；同时，通过从这个抽象体派生，也可扩展此模块的行为功能。熟悉OCP的读者一定知 道，为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。

符合开发封闭原则，我可以对抽象出来的类进行扩展，但是只要是这个抽象类的子类，那么他必然能够。

从语法层面上讲，java单继承多实现，而接口可以多实现。



## java里的枚举实现机制是什么

枚举类型在编译器处理之后，是由一个final的继承Enum类的类实现的。该类是一个实实在在存在的类。在该类当中，编译器还帮助我们生成了每个枚举类型的实例对象，这些对象分别对应枚举中定义的每个枚举类型本身。



# 什么是SOA
SOA 即 service-oriented architecture，翻译成中文就是面向服务的架构。是一种服务器架构理念。

是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。

SOA具有以下五个特征：
1、可重用
一个服务创建后能用于多个应用和业务流程。
2、松耦合
服务请求者到服务提供者的绑定与服务之间应该是松耦合的。因此，服务请求者不需要知道服务提供者实现的技术细节，例如程序语言、底层平台等等。
3、明确定义的接口
服务交互必须是明确定义的。Web服务描述语言（Web Services Description Language，WSDL）是用于描述服务请求者所要求的绑定到服务提供者的细节。WSDL不包括服务实现的任何技术细节。服务请求者不知道也不关心服务究竟是由哪种程序设计语言编写的。
4、无状态的服务设计
服务应该是独立的、自包含的请求，在实现时它不需要获取从一个请求到另一个请求的信息或状态。服务不应该依赖于其他服务的上下文和状态。当产生依赖时，它们可以定义成通用业务流程、函数和 数据模型。
5、基于开放标准
当前SOA的实现形式是Web服务，基于的是公开的W3C及其他公认标准．采用第一代Web服务定义的SOAP、WSDL和UDDI以及第二代Web服务定义的WS-*来实现SOA。





# 关于资源池

资源池不仅仅是在java当中存在的概念，在软件世界里也是广泛应用的一个东西。

我们非常常见的资源池有：

数据库连接池
web容器中的线程池
web容器中的request,response对象池
使用资源池的原因和好处大致是相似的。无外乎创建关闭维护每一个资源是比较耗费成本的。因此我们可以维护一定数量的资源，来寻求一个效率上的平衡。

资源池引入的目的:提高性能
资源池运作机制：由资源池管理器提供一定数目的目标资源，当有请求该资源时，资源池分配给一个，然后给该资源标识为忙，    标   示为忙的资源不能再被分配使用，
资源池常有的参数  初始资源的数目：资源池启动时，一次建立的资源数目，资源池最少要保证在这个数目上.  最大资源的数目：当请求的资源超出这个数目，就等待。



# 递归



1 定义：程序调用自身的编程技巧称为递归（ recursion)

特点：一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合

2 组成

边界条件
递归前进段
递归返回段
当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

3 条件

子问题须与原始问题为同样的事，且更为简单；
不能无限制地调用本身，须有个出口，化简为非递归状况处理
4 生活中递归的表现

德罗斯特效应是递归的一种视觉形式。图中女性手持的物体中有一幅她本人手持同一物体的小图片，进而小图片中还有更小的一幅她手持同一物体的图片，依此类推。


我们在两面相对的镜子之间放一根正在燃烧的蜡烛，我们会从其中一面镜子里看到一根蜡烛，蜡烛后面又有一面镜子，镜子里面又有一根蜡烛……这也是递归的表现
从小就听过的例子：从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山...
但是上述例子是和递归相似的场景，但是软件当中定义的递归是要有一个终止条件的，否则就是死循环了。

5 递归算法一般用于解决三类问题

数据的定义是按递归定义的。（Fibonacci函数）
问题解法按递归算法实现。这有的虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
数据的结构形式是按递归定义的。
如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述

6 递归的缺点

递归算法解题相对常用的算法如普通循环等，运行效率较低
在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。





# 关于java语法





# continue关键字和break关键字
continue关键字

使用地方：continue关键字只能用于循环结构。
作用: 跳过本次循环，重新开始下一趟循环。

例子：

public class HelloWorld {
    public static void main(String[] args) {
          

        //打印单数     
        for (int j = 0; j < 10; j++) {
            if(0==j%2)  
                continue; //如果是双数，后面的代码不执行，直接进行下一次循环
             
            System.out.println(j);
        }
    }
}
打印结果是：1 3 5 7 9。

break关键字

使用地方：用于switch结构和循环结构

作用:
1.如果用于switch结构，跳出当前的case语句
2.如果用于循环结构中，跳出当前循环结构。

例子：

public class HelloWorld {
    public static void main(String[] args) {
          
        //打印单数     
        for (int j = 0; j < 10; j++) {
            if(0==j%2)  
                break; //如果是双数，直接结束循环
             
            System.out.println(j);
        }
    }
}
打印结果是：什么都不打印

# this关键字
this关键字代表对象自身，如果new了一个对象之后，则这个this就是一个指向这个对象自己的一个引用，如下图：



根据上述描述，我们知道this是用于在方法内部获取当前对象的引用的关键字，其用法与其他引用并无不同。

用途：

 this调用本类中的属性，也就是类中的成员变量
 this调用本类中的其他方法；
 this调用本类中的其他构造方法，调用时要放在构造方法的首行。
这几点都非常好理解，因为指向的是对象自身，能操作的自然都是成员变量以及类的方法。有了这些知识之后，我们再来看一个java代码里经常看到的构造方法写法：

public class Test{

    private String s;
    
    public Test(String s){
        this.s = s;
    }
}
初学者常常对这里有两个s感到困惑，现在我们就知道了，等号左边的this.s获取的是当前对象即外部的s字符串，而等号右边的s则必然是括号里的参数，因此这就把括号里的参数赋值给了成员变量s。this常常用于这种成员变量名字和方法参数一样的情形。

最后，我们来扩展一点题外话，关于static关键字。理解了this关键字之后，static关键字就能更加全面的被理解。static方法就是没有this的方法。注意这里需要仔细理解这个没有的意思。为什么说没有，是因为在static方法内部不能调用非static的方法，但反过来是可以的，且不需要创建对象。因此static方法很很像全局方法，关于static的用法，请参考另一篇单独的博客：[java] static关键字总结.








# final关键字
final是java的一个关键字，他可以用于修饰类，方法，变量。此关键字的作用在于表明它所修饰的内容是不可改变的。

1 修饰变量

final顾名思义是最终的意思，他修饰变量意味着这个变量的值不能再更改。一个即是static又是final的常量会占据一段不能改变的内存空间。对于这样的常量，我们的命名规范是约定俗成的大写字母加下划线，如下：

private static final int TEST_FINAL = 1;
在修饰引用变量的时候，这个值是指的其引用不变，但引用的对象的内容是可变的。而在修饰基本变量如int时，则意味着这个基本类型的值不能改变。值得注意的是,final在修饰String类的对象时，其值和修饰基本变量类型是一样不能改变的。答案可以在这篇博客中找到：[Java] String类深度解析。这里不再展开。

2 修饰方法

final修饰的一个方法代表这个方法可以被继承，但是不可以被子类重写。一般对一个方法加上final关键字作为修饰，代表这个方法你认为不需要再重写和修改，而是想要确保在继承中方法的行为保持不变。

在过去，建议使用final 方法的另一个原因在于效率，final方法是在程序编译的时候就静态绑定了，但是在如今的jvm中这个速度已经可以忽略不计了。并且，也不再建议出于效率目的使用final。

此外，一个类中所有的private方法都是隐式的被指定为final 的。因此对private方法添加final关键字没有任何意义。private方法不能被取用，因此也无法覆盖。

3 修饰类

final类不能被继承，其修饰的类功能通常是完整的。

与finally区别？finally 通常用在异常处理中。异常处理可以参考这篇文章：java异常机制详解。

与finalize区别？finalize是在Object类中定义的方法，是在垃圾回收时虚拟机调用来终结对象的方法。







# transient关键字
我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。关于此关键字需注意下面三点：

一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。



## Super关键字

主要存在于子类方法中，用于指向子类对象中父类对象。其作用包括下面几种

- 访问父类的属性
- 访问父类的函数
- 访问父类的构造函数





## return关键字

return 关键字在java里面有两方面用途：

- 指定一个方法返回什么值
- 退出当前方法，并返回指定的值

对于返回值为void的方法，我们可以不写return语句，原因在于结尾处会生成一个隐式的return。





# instanceof关键字

Instanceof关键字的作用是返回一个布尔值，告诉我们一个对象是不是某个特定类的一个实例。例如:

if(x instanceof Dog){

}
即在判断x对象是不是Dog类的一个实例。

Instanceof关键字是RTTI，动态类型判断技术的其中一种表现形式。关于RTTI的更多内容，请参考这篇博客:[java] 反射和多态实现原理详解以及对比.





# java里的方法重载
所谓方法重载，指的是当两个方法具有相同的方法名称的时候，他们共存的一种方式。下面是两个重载方法的例子:

public class TestOverloading {
    public void method(String s){

    }
    public void method(int  i){
     
    }
}
对于方法名称相同的：

参数数量一样，类型不一样，可以重载
参数数量不一样可以重载
参数数量一样，相同位置类型不一样，可以重载
对于第三种情况,实例代码如下：

public class TestOverloading {
    public void method(String s, int i){

    }
    public void method(int  i, String s){
     
    }
}
注意，方法返回值不作为方法标识之一，下列方法是不能重载的

public class TestOverloading {
    public int method(  int i){
        return 1;
    }
    public String method(int  i){
        return "2";
    }
}





# 关于类Collections,Arrays,Objects
在jdk源代码中提供了很多有用的工具类，它们的命名也有一定的规律。

Collections类提供了很多给容器使用的实用方法。

Arrays类提供了很多给给数组容器有用的方法。例如想创建一个数组对象可以直接调用方法Arrays.asList(...)

Objects类提供了一些给Object类中的实用方法.

这些类都位于jdk的java.util包下面。除了上面提到的三个类以外，util包下面还有许多非常有用且也经常被用到的类和包，例如正则表达式相关的类，基本类型转换的类，以及流编程的类等等，感兴趣的读者可以自行查看。








# java中的内部类
定义：将一个类的定义放在另一个类的定义内部，即为内部类。

内部类本质上是java的一种"语法糖"。为什么这样说呢？举例说明，假设现在有如下代码：

public class A {
    private int a;
    static class B {

    }
     
    class C {
        public void test(){
            int b  = a;
        }
    }
}
类A是一个普通的类，在他的内部定义了两个类B，以及C。从代码结构上来看，B类和C类为A类的内部，但是在使用编译器编译之后，它们并不是一个类，而是会变成符合一定名称规则的三个类，如下图所示：



它在编译之后会产生三个.class文件，分别是：A.class, A$B.class, A$C.class. 因此，本质上它们还是三个类，只是借助于java编译器的语法糖支持，我们可以写在一个类里面，从这个例子我们不难推断出，在java 里任何一个类，无论是以怎样的形式定义，在编译之后生成字节码文件之后，其必然是一个单独存在的类。理解java的类加载机制的话对这句话理解起来就更加容易，java加载任何一个类的时候都是会首先从加载其class文件开始，若一个类不存在对应的class文件，那么它必然无法被加载也无法被使用。

同时，知道了上述知识之后，我们来看这样两个问题：

内部类可以被继承吗？答案是肯定可以的，只是从java语法来说写起来会稍微有点区别
内部类的方法可以被覆盖吗？答案一样是可以的。
为何java编译器会支持定义内部类这样的使用方式，原因在于当一个类定义在另一个类内部之后，许多操作会变得简单一些，比如一个内部类可以直接访问外部类的任何成员。为什么内部类能直接访问外部类的任何成员呢？原因在于java编译器对内部类的功能t提供了支持，让我们再来看上述代码反编译回来的结果：

public class A {
    private int a;

    public A() {
    }
     
    class C {
        C() {
        }
     
        public void test() {
            int b = A.this.a;//通过类名加this关键字
        }
    }
     
    static class B {
        B() {
        }
    }
}
可以看到是通过类名跟上.this关键字实现的对外部成员的访问，这相当于是隐式的持有了一个外部类引用，即建立了一个内部类和外部类之间的联系。

同时，这里我们需要注意这里的B类声明成了static的类，C类则没有。我们常常把用static修饰的内部类成为嵌套类。

他们的区别在于，嵌套类与外围类之间是没有联系的。这意味这创建嵌套类无需外部类，当然，也不能从嵌套类的对象中访问非静态的外围类对象。同时，在嵌套类的内部可以使用static关键字，而普通的内部类不能使用static关键字。

用途：从代码的组织结构来说，使用内部类可以把逻辑相关的类组织在一起。内部类访问外部类将非常方便，内部类能访问外围对象的所有成员，且不需要任何特殊条件。但这不是最主要的原因，从设计角度出发，使用内部类最大的原因在于：每个内部类可以独立但继承一个类，这意味着虽然java的类是单继承的，但是通过使用内部类，可以达到类似多重继承的效果。因此，如果不需要解决多重继承的问题，使用内部类就并不是必须的了，因为其他的编码方式都能实现一样的效果。

关于其他语法糖的介绍可以参考博客:java中的语法糖
